# Title: Java

Date: 2014-12-10 19:01
Tags: []
Categories: []

<!-- toc -->

---

## Prelude

- CDI/Weld : Refs: <2015-08-02-cdi-weld.md>

## Java SE

### Code idiom

- {}をただのブロックとして使用可能。テストケースとかで、同じ変数名をコピペしたいとかの時に重宝する。
    ただ、ややこしいし、無駄に複雑に見えるのでプロダクトコードでは使わないこと！

        // 以下は変数名重複とならない
        { int a = 1;}
        { int a = 2;}

- ゼロ埋め :

        String.format("%03d", number); // 001, 002…

- メソッド名取得

        Thread.currentThread().getStackTrace()[0].getMethodName()

- Mapのインスタンス作成時に値も挿入するイディオム

        Map<String, Integer> map = new HashMap<String, Integer>() {
            {
                put("one", 1);
            }
        };

- オブジェクトのディープコピー

        private static <T> T deepCopy(T target) {
            if (target == null) {
                return null;
            }
            try (ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
                    ObjectOutputStream oos = new ObjectOutputStream(bos);) {
                oos.writeObject(target);
                try (ByteArrayInputStream byteIn = new ByteArrayInputStream(bos.toByteArray());
                        ObjectInputStream ois = new ObjectInputStream(byteIn)) {
                    return (T) ois.readObject();
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

- ランダムなバイト配列取得

        byte[] b = new byte[20];
        new Random().nextBytes(b);

- 乱数(ランダム値)取得

        // コンストラクタとかでRandomをnewしておいて、それを使ってnextIntを呼び出すのが一番よい。
        new Random().nextInt(n)

    \* (int)Math.random()×(n+1)は効率が悪いので基本↑でやる。  
    Refs: [Math.random()×n か それともRandom.nextInt(n)か - いろいろがんばりたいブログ](http://pushl.hatenablog.com/entry/2012/11/03/004027)

- CPU論理コア数取得

        int core = Runtime.getRuntime().availableProcessors();

- クラスパス上のファイル読み込み

        TestMain.class.getClassLoader().getResouce("foo/bar/test.properties"));
        TestMain.class.getResouce("/foo/bar/test.properties"));
        TestMain.class.getResouce("test.properties"));
        // getResourceAsStreamも同様
        // 基本位置に依存したくないのでgetClassLoaser().getResource()を使えばよさそう

    Refs: [あるプログラマーのワークスペース: getResourceAsStream()でリソースが読み込めない](http://aarkiton.blogspot.jp/2011/09/getresourceasstream.html)

### Java 8

java.io.UncheckedIOException

Stream処理におけるException Tunnelingのために追加された例外。
UncheckedIOException例外クラスは、従来からある検査例外java.io.IOExceptionをラップする目的で、java.lang.RuntimeExceptionから派生した非検査例外(unchecked exception)である。

### Javadoc

- @since, @version
    - @since : 導入されたバージョン
    - @version : 現在のバージョン
        - メソッドに対しては指定不可

## Other command

- javadoc生成

        javadoc -d D:/admin/Desktop/javadoc -encoding "utf-8" -charset "utf-8" *.java

- jarの中身を確認

        jar tf hoge.jar

- スレッドダンプ取得

        jstack {pid}

- JavaのプロセスID表示

        JPS

## Memo

- 無名内部クラスでは、そのクラスのコンストラクターを定義することは出来ない。
    - Refs: [Javaクラス使用メモ(Hishidama's Java Class use Memo)](http://www.ne.jp/asahi/hishidama/home/tech/java/class_use.html#anonymous_class)
- GlassFish:
    GlassFishは、サンを中心としたオープンソース・コミュニティと、同コミュニティで開発されたJava EE準拠のアプリケーションサーバの名称である。
- WildFly
    JBossが開発するOSSのJavaEEアプリケーションサーバ
- JAAS（Java Authentication and Authorization Service）
    認証を実現するための標準API
    - JAAS認証    ・IDやパスワードなどを利用して認証を行うことで、ユーザーの正当性を判定
        Javaを実行しているユーザーに正当性があることを確認
    - JAAS承認    ・アプリケーションによって、リソースへのアクセス要求が許可できるのかを判定
        ユーザーに対するアクセス権の保持を判定

### Version - 実行可能バージョンについて

> javacでコンパイルするとclassファイルが作られるが、classファイルの中には「どのバージョンのJavaVMで実行できるか」という“Javaクラスの形式”のバージョンが書かれる。[2007-05-15]  
> JavaVM（javaコマンド）では実行できるバージョンが限られており、自分より新しいバージョンで作られたclassファイルは実行することが出来ない （古すぎてもダメ）。

Refs: [Javaアプリケーション メモ(Hishidama's Java-Application Memo)](http://www.ne.jp/asahi/hishidama/home/tech/java/application.html#Java-version)

#### クロスコンパイルオプション

-target version

> 指定されたバージョンの VM をターゲットにしたクラスファイルを生成します。このクラスファイルは、指定されたターゲット**以降**のバージョンでは動作しますが、それより前のバージョンの VM では動作しません。

\* 太字引用者

Refs: [javac - Java プログラミング言語コンパイラ](http://docs.oracle.com/javase/jp/7/technotes/tools/solaris/javac.html)

## JUnit

- Classクラスを比較(意外とめんどい)
    - assertEqualsを使う(簡単だが非推奨)
            assertEquals(factory.getMessageType(), Integer.class); // TODO: wrapper classでよいか
    - assertThatを使う
        - かんたん(これでいけるっぽい)
                assertThat(Class, is((Object) Class));
        - がんばる(失敗したときわかるようにdescriptionつけたほうがよい)
                assertThat("actual is " + factory.getMessageType(), factory.getMessageType() == Integer.class, is(true));
        - hamcrest.object.IsCompatibleTypeを使う(coreには入ってないっぽい。。)
                assertThat("クラスから型を検査", ArrayList.class, is(typeCompatibleWith(List.class)));
    - Refs:
        - [実はJUnit4のassertThat()ってしっくりこないんです！（特に、メタプログラミングするレイヤでは） - 達人プログラマーを目指して](http://d.hatena.ne.jp/ryoasai/20110502/1304339487)
        - [hamcrestのMatcherメモ - 都元ダイスケ IT-PRESS](http://d.hatena.ne.jp/daisuke-m/20090710/1247181113)
- equalTo と is
    > is は equalTo の構文糖であるため、以下は全て等価です。
    >
    > assertThat(actual, equalTo(expected));
    > assertThat(actual, is(equalTo(expected)));
    > assertThat(actual, is(expected));
    > 英語として読み下し易くするために、is に matcher を渡すのが普通です。
- 指定したパッケージのテストをすべて実行するTestSuite :
    標準では無理らしい(ライブラリはありそう) Refs: [java - JUnit4 run all tests in a specific package using a testsuite - Stack Overflow](http://stackoverflow.com/questions/7331214/junit4-run-all-tests-in-a-specific-package-using-a-testsuite)

## Maven

- テストスキップ:
    - テストの実行のみをスキップする

            mvn hoge -DskipTests=true

    - テストコードのコンパイル、およびテストの実行をスキップする

            mvn hoge mvn install -Dmaven.test.skip=true

    > 後者の場合、jar:test-jar(org.apache.maven.plugins:maven-jar-plugin:test-jar) もスキップされるようになるため、意図的に *-tests.jar を作成している場合は注意が必要です。

- 依存するライブラリのソースをダウンロード

        mvn clean eclipse:eclipse -DdownloadSources=true -DdownloadJavadocs=true

- 大きなメモリ領域を割り当てる
    - consoleで実施

            set MAVEN_OPTS=-Xmx2048M

        Refs: [Maven2で大きなメモリ領域を割り当てる - wutseのダイアリー](http://d.hatena.ne.jp/wutse/20071102/1193975925)
    - eclipseで実施
            "Run As" - "Maven Build", click on the "JRE" tab, enter VM args e.g. : -Xms128M -Xmx512M
        Refs: [memory - Increase heap size in m2e Eclipse plugin - Stack Overflow](http://stackoverflow.com/questions/7899221/increase-heap-size-in-m2e-eclipse-plugin)

- プロファイルを指定

        mvn -P dev
        mvn -P dev,test

### Phase

mvnコマンドの引数に渡す、行いたいことを"Phase"という。(e.g. clean, validate, compile)

Refs: [Mavenの使い方 Maven3のはじめかた](https://kengotoda.gitbooks.io/what-is-maven/content/primer/abstract.html)

### Build Lifecycle

複数のPhaseのつながりをビルドライフサイクルという。(e.g. default, clean)

Refs:

- [ビルド・ライフサイクル Maven3のはじめかた](https://kengotoda.gitbooks.io/what-is-maven/content/primer/build-lifecycle.html)
- [Undertree's Lab: Mavenのビルドライフサイクル](http://undertrees-lab.blogspot.jp/2011/11/maven.html)

### Plugin

- Apache Maven Javadoc Plugin

        mvn javadoc:javadoc

- Apache Maven Eclipse Plugin

        mvn eclipse:eclipse

- Apache Maven Dependency Plugin

        mvn dependency:tree

- Maven Help Plugin

        mvn help:effective-pom

- Maven Graph Plugin
    - サブモジュール間の依存関係グラフ表示

            mvn org.fusesource.mvnplugins:maven-graph-plugin:reactor -Dhide-external=true

### Apache Maven Dependency Plugin

- コマンドラインで指定したartifactを取得

        mvn dependency:get -DgroupId=javax -DartifactId=javaee-api -Dversion=7.0

    - ソースコード取得

            mvn dependency:get -DgroupId=javax -DartifactId=javaee-api -Dversion=7.0 -Dclassifier=sources

    - 取得ディレクトリ指定

            mvn dependency:get -DgroupId=javax -DartifactId=javaee-api -Dversion=7.0 -Ddest=.

- dependency の conflict を表示

        mvn dependency:tree -Dverbose -Dincludes=commons-collections

    Refs: [ApacheMavenDependencyPlugin&#x2013;Resolvingconflictsusingthedependencytree](https://maven.apache.org/plugins/maven-dependency-plugin/examples/resolving-conflicts-using-the-dependency-tree.html)

### Maven Help Plugin

- 有効なpomを表示

        mvn help:effective-pom

- 有効なsettingsを表示

        mvn help:effective-settings

